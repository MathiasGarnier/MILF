{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Math\u00e9matiques. Informatique. Linguistique. Formalisation.","text":"<p>Sur ce petit blog, je vous parle de tout ce que j\u2019apprends dans l\u2019optique de faire un assistant de preuve et des \u201cmath\u00e9matiques embarqu\u00e9es\u201d !</p> <p>Je pars vraiment de z\u00e9ro et mon but est de tout expliquer (de fond en comble !).</p>"},{"location":"#derniere-avancee","title":"Derni\u00e8re avanc\u00e9e","text":"<ul> <li>\u00c9criture d'un compilateur miniature.</li> </ul>"},{"location":"#billets","title":"Billets","text":"<ul> <li> <p>0 - Objectifs initiaux</p> </li> <li> <p>1 - R\u00e9inventer la roue</p> </li> <li> <p>2 - Premier compilateur miniature</p> </li> <li> <p>3 - Cori et Lascar (d\u00e9buts)</p> </li> <li> <p>4 - L'entr\u00e9e au Fab Lab</p> </li> <li> <p>5 - Ben Eater (et cie), ces h\u00e9ros...</p> </li> </ul> <p> </p> <p>P.S. Le nom du projet (M.I.L.F.) n'\u00e9tait pas volontaire.</p>"},{"location":"blog/0-objectifs-initiaux/","title":"0 - Objectifs initiaux","text":"<p>Il est relativement compliqu\u00e9 d'avoir une id\u00e9e (rien qu'un peu) pr\u00e9cise de ce que je souhaite faire. D\u00e9couvrant \u00e0 peine ce nouveau monde (design de compilateurs, formalisation, programmation (tr\u00e8s) bas niveau...), il est difficile de savoir exactement par o\u00f9 commencer et surtout o\u00f9 aller !</p> <p>Pour donner une id\u00e9e, voici une liste (\u00e0 la vol\u00e9e) de termes que je vois passer mais dont je n'ai aucune id\u00e9e du sens qu'ils poss\u00e8dent / de leur fonctionnement / d\u00e9finition / utilisation pr\u00e9cise : Turing-complet, machine de Turing, logique du premier ordre (etc), th\u00e9orie des types, CPU, RAM, (acc\u00e9l\u00e9ration) GPU, lambda calculus, complexit\u00e9, preuve, registre, circuit imprim\u00e9, s\u00e9mantique, grammaire...</p> <p>M\u00eame si le vocabulaire manque, essayons tout de m\u00eame de d\u00e9crire ce que je souhaite faire (au moins sommairement dans un premier temps).</p>"},{"location":"blog/0-objectifs-initiaux/#une-premiere-idee","title":"Une premi\u00e8re id\u00e9e","text":"<p>Prenons l'exemple de Lean. C'est un assistant de preuve. Concr\u00e8tement, il prend en entr\u00e9e un jeu de donn\u00e9es (cha\u00eene de caract\u00e8re ayant un sens dans un langage pr\u00e9cis) qu'il va \u00eatre capable \"d'\u00e9valuer\" puis de \"traiter\". Une fois fait, son utilit\u00e9 r\u00e9side notamment dans le fait de \"certifier\" de la justesse de la preuve ! (Lean est m\u00eame incroyablement plus fort que cela en permettant diverses automatisations...)</p> <p>Essentiellement, Lean est un langage \u00e9crit en C++ (cf. github). Comme exemple d'utilisation, un utilisateur programmerait en Lean sur VSCode sur Windows / Linux / McIntosh... Avant que le processeur soit sollicit\u00e9 beaucoup d'interm\u00e9diaires vont s'interposer (m\u00eame si ce sera un temps relativement court). Assez b\u00eatement, je me suis demand\u00e9 s'il ne serait pas possible d'\u00e9crire un langage (au plus proche du processeur) op\u00e9rant dans une logique similaire \u00e0 celle de Lean. N\u00e9anmoins, ne pourrait-on pas aller plus loin ?</p> <p>Dans quelle direction aller ? Pour tenter de m'expliquer un petit peu, je vais faire une explication d\u00e9tourn\u00e9e : semblerait-il que tous les langages assembleurs poss\u00e8dent une instruction <code>add</code> (et plus g\u00e9n\u00e9ralement celles de l'arithm\u00e9tique (binaire ou pas) de base). Fondamentalement, si je ne suis pas trop dans l'erreur, dans un assistant de preuve, on ne va jamais \"prouver\" que \"deux et deux font quatre\". En revanche, on va prouver que la mani\u00e8re de faire l'addition implique qu'en raisonnant sur un certain alphabet / langage (d\u00e9finit arbitrairement; les nombres usuels par exemple) conduira \u00e0 obtenir des \u00e9quivalences / \u00e9galit\u00e9s purement num\u00e9riques (2 + 2 = 4). Mon id\u00e9e serait de baser le langage non sur des instructions au processeurs usuelles mais de \"d\u00e9tourner\" le fonctionnement habituel d'un ordinateur pour \"raisonner\" sur des donn\u00e9es \"symboliques\" et non sur des op\u00e9rations arithm\u00e9tiques brutes. (Comment d\u00e9finir alors un tel objet ? Est-ce seulement possible ? A-ce seulement un sens ?)</p> <p>Dit autrement, l'id\u00e9e est de calquer la v\u00e9rification et la formalisation de preuve sur l'architecture m\u00eame d'un processeur (tout en ayant un petit peu bidouill\u00e9 le \"fonctionnement originel\").</p> <p>On m'a parl\u00e9 de VHDL et Verilog (wow). \u00c0 voir bien plus tard.</p>"},{"location":"blog/0-objectifs-initiaux/#une-idee-du-travail-quelques-taches-a-accomplir","title":"Une id\u00e9e du travail (quelques t\u00e2ches \u00e0 accomplir)","text":"<p>Je suis th\u00e9oriquement parti pour... longtemps. Dans l'optique d'un d\u00e9roulement pas trop chaotique du projet, je suis cens\u00e9 r\u00e9aliser bon nombres de prototypes (qui, dans leur ordre de r\u00e9alisation, ne correspondent aucunement \u00e0 une quelconque priorisation des objectifs).</p> <p>Pour l'instant (et depuis ma prime adolescence), je me passionne pour le design de compilateur. Il ne m'aura fallu que cinq / six ann\u00e9es pour me lancer... Ben m'a fait d\u00e9couvrir beaucoup de choses et continue \u00e0 m'en faire d\u00e9couvrir beaucoup. Aujourd'hui, et c'est l'occasion d'un des prochains billets, j'ai mon petit compilateur source-to-source et c'est un heureux d\u00e9but... </p>"},{"location":"blog/0-objectifs-initiaux/#le-temps-des-compilateurs","title":"Le temps des compilateurs","text":"<p>Honn\u00eatement, c'est la jungle. \u00c7a part dans tous les sens, faire un truc propre est loin d'\u00eatre trivial.</p>"},{"location":"blog/0-objectifs-initiaux/#le-temps-du-fonctionnement-systeme","title":"Le temps du fonctionnement syst\u00e8me","text":""},{"location":"blog/0-objectifs-initiaux/#le-temps-des-performances-et-cette-idee-qui-mechappe-loptimisation","title":"Le temps des performances et cette id\u00e9e qui m'\u00e9chappe : l'optimisation","text":""},{"location":"blog/0-objectifs-initiaux/#un-niveau-en-dessous","title":"Un niveau en dessous","text":"<p>Au fond, le C est tr\u00e8s haut niveau ().</p>"},{"location":"blog/0-objectifs-initiaux/#le-temps-des-cathedrales","title":"Le temps des cath\u00e9drales","text":"<p>==&gt; l'architecture / \u00e9lectrocin\u00e9tique et cie</p>"},{"location":"blog/0-objectifs-initiaux/#mastering-lean","title":"Mastering Lean","text":""},{"location":"blog/0-objectifs-initiaux/#le-formalean-inator","title":"Le formalean-inator !","text":"<p>Il va bien falloir que j'apprenne \u00e0 manier un assistant de preuve un jour ou l'autre ! Ce serait bien de le faire avec un bon petit projet en t\u00eate (par exemple celui du second semestre : formaliser \"enti\u00e8rement\" la preuve du r\u00e9sultat que l'on devra montrer; n'ayant pas encore le sujet, je ne sais pas vraiment ce qu'il en retourne).</p> <p>Le choix de Lean est purement subjectif mais divers points renforcent cette d\u00e9cision : une communaut\u00e9 d\u00e9bordante et active (par exemple sur leur forum), une sacr\u00e9e documentation (sur leurs sites : microsoft ou communautaire; ou directement sur github).</p> <p>Dans un second temps, \u00e9crire un micro-lean (un premier assistant de preuve) serait simplement merveilleux.</p>"},{"location":"blog/0-objectifs-initiaux/#beaucoup-de-mathematiques-et-dinformatique-theorique","title":"Beaucoup de math\u00e9matiques et d'informatique th\u00e9orique","text":"<p>En parall\u00e8le de chacune de ces \u00e9tapes, il va falloir se documenter sur les bases math\u00e9matiques / informatiques de chacun des objets.</p>"},{"location":"blog/0-objectifs-initiaux/#ne-pas-abandonner","title":"Ne pas abandonner","text":"<p>Il faut tenir bon et ne pas baisser les bras. Adoptons la philosophie Vulkan :</p> <p>It's also important to keep in mind that once you have that boring looking triangle, drawing fully textured 3D models does not take that much extra work, and each step beyond that point is much more rewarding.</p> <p>Au travail, il ne faut pas se d\u00e9courager (surtout pas au d\u00e9but) !</p>"},{"location":"blog/1-reinventer-la-roue/","title":"1 - R\u00e9inventer la roue","text":"<p>Fondamentalement, beaucoup de choses existent d\u00e9j\u00e0 (assistants de preuve : Coq, Isabelle, Lean, HOL; langages de programmation; syst\u00e8mes embarqu\u00e9s...). Tr\u00e8s justement, un ami m'a alors demand\u00e9 pourquoi je faisais cela.</p> <p>Mon intention de r\u00e9inventer la roue s'explique (partiellement) par les trois points suivant :</p> <ul> <li> <p>Voir comment tout se construit, comprendre chaque rouage. Je ne sais pas (je ne pense pas) \u00eatre capable d'avoir des id\u00e9es novatrices donc autant essayer d'\u00e9tudier un maximum de choses qui existent d\u00e9j\u00e0. D\u00e9cortiquer et essayer de tout reconstruire (en modifiant certains aspects dans l'optique de r\u00e9aliser mon projet).</p> </li> <li> <p>Un probl\u00e8me de confiance, sans doute. Tant que je n'ai pas vu de mes propres yeux qu'en effet c'\u00e9tait possible... je reste dubitatif.</p> </li> <li> <p>C'est cool.</p> </li> </ul> <p>Comme le disait Saint Augustin (j'esp\u00e8re que sa citation n'est pas apocryphe): </p> <p>Il vaut mieux suivre le bon chemin en boitant que le mauvais d'un pas ferme.</p> <p>Je vais donc bo\u00eeter, avancer tr\u00e8s lentement en re-construisant (quasiment... faut pas d\u00e9conner non plus) tout de z\u00e9ro. Un tel chemin (me) semble plus int\u00e9ressant qu'accepter que des solutions clefs en mains fonctionnement parfaitement.</p> <p>Puis, il faut sans doute dire que j'ai une tendance \u00e0 accumuler tous mes projets et les faire s'agr\u00e9ger les uns aux autres au fur et \u00e0 mesure. Ce projet (M.I.L.F.) est une forme de point d'orgue pour moi : tous mes projets s'y sont agglutin\u00e9s. Je vais donc r\u00e9inventer la roue, recommencer quasiment chacun de mes projets en prenant en compte l'exp\u00e9rience accumul\u00e9e.</p>"},{"location":"blog/2-premier-compilateur-miniature/","title":"2 - Premier compilateur miniature","text":"<pre><code>LET x = 0\n\nFUNCTION(STRING) mafonction (NUMBER i, STRING s, NUMBER j) DO\n    PRINT i * 2\n    RETURN s\nENDFUNCTION\n\n\nFUNCTION(NUMBER) mafonction2 (NUMBER l, STRING k, NUMBER m) DO\n    PRINT l * 2\n    RETURN l\nENDFUNCTION\n</code></pre> <p>Yeahhh, \u00e7a compile (ou plut\u00f4t transpile...). Il ne se passe pas grand chose mais c'est mon premier (grand) pas. C'est aussi la premi\u00e8re fois que j'avoisine les mille lignes de code (cela m'a permis de me rendre compte que quand j'\u00e9tais petit je voulais faire des projets inutilement longs et d\u00e9sormais : plus c'est court et bien pens\u00e9, mieux ce sera).</p> <p>J'ai suivi un magnifique petit tutoriel de Austin Z. Henley qui se d\u00e9composait en trois parties : le lexer, le parser et l'emitter. J'ai pu un petit peu parl\u00e9 avec lui, et, il m'a notifi\u00e9 la sortie (imminente) d'un livre de sa confection sur le sujet (yeahhh). Une fois fini, il invite \u00e0 aller plus loin (en impl\u00e9mentant la notion de <code>FUNCTION</code> par exemple). Il reste pas mal de choses \u00e0 faire mais je crois avoir compris la logique. Essayons de la r\u00e9sumer :</p>"},{"location":"blog/2-premier-compilateur-miniature/#fonctionnement-naif-dun-compilateur","title":"Fonctionnement (na\u00eff) d'un compilateur","text":"<p>On oublie les histoires d'optimisation etc... On ne se concentre que sur le fonctionnement \"primitif\" / intrins\u00e8que.</p>"},{"location":"blog/2-premier-compilateur-miniature/#quelques-sources","title":"Quelques sources","text":"<p>Austin Henley a conseill\u00e9 ce livre : Crafting Interpreters de Robert Nystrom. Il est juste magnifique !!! (Et accessible en ligne.) Je suis quasiment convaincu que je vais le lire. Il faudrait aussi lire le Dragon Book (au moins pour la culture, une r\u00e9\u00e9dition semble avoir \u00e9t\u00e9 faite).</p>"},{"location":"blog/3-Cori-Lascar-debuts/","title":"3 - Cori et Lascar (d\u00e9buts)","text":"<p>Lecture \u00e0 peine commenc\u00e9e (depuis moins d'une semaine) et \u00e7a fait d\u00e9j\u00e0 mal (je s\u00e8che sur les premiers exercices) ! N\u00e9anmoins, vraie r\u00e9v\u00e9lation ! J'ai tout juste commenc\u00e9 et \u00e7a met une claque de voir un langage se d\u00e9velopper sous ses yeux pour prouver des choses qui semblent hyper-intuitives. N\u00e9anmoins, ma\u00eetriser ce langage requiert pas mal (beaucoup, pour ma part) d'efforts. </p> <p>(Par exemple, la d\u00e9monstration de l'unicit\u00e9 de l'arbre de d\u00e9composition d'une formule m'a laiss\u00e9 sur le cul.)</p> <p>Les commentaires de maxtimax, un fin connaisseur du sujet (et de bien plus, une histoire de m\u00e9langes entre homotopie, logique et topologie) m'a dit cela :</p> <p>De toute fa\u00e7on, il ne faut jamais s'inqui\u00e9ter de prendre du temps, c'est bien de prendre du temps sur des exercices m\u00eame si c'est du temps o\u00f9 on gal\u00e8re :). C'est des maths auxquelles on n'est pas habitu\u00e9-e, donc il y a aussi un temps d'adaptation. </p> <p>C'est s\u00fbr que c'est d\u00e9concertant et pas toujours \u00e9vident de voir l'utilit\u00e9 du pourquoi du comment tel objet a \u00e9t\u00e9 introduit. Autant, l'utilit\u00e9 de la hauteur (d'une formule m'est venue de suite). En revanche, j'ai cru que tout le raisonnement sur les parenth\u00e8ses \u00e9tait une blague ou alors une rigueur excessivement lourde pour peu. Quelle fut ma surprise \u00e0 la fin de la premi\u00e8re partie du premier chapitre du premier livre ! La premi\u00e8re fois que je sens l'utilit\u00e9 du parenth\u00e8sage (au-del\u00e0 de sa n\u00e9cessit\u00e9 pour que les choses fassent au moins semblant de marcher en programmation par exemple). </p> <p>Rq. Semblerait-il qu'avoir de bonnes bases en topologie pourrait \u00eatre appr\u00e9ciable (\u00e7a se ressent d'ailleurs tr\u00e8s rapidemment avec des espaces topologiques de trucs / structures bool\u00e9ennes (?)). Le bouquin de Testard Analyse Math\u00e9matique -- La ma\u00eetrise de l'implicite donne un premier bel avant go\u00fbt (agr\u00e9ablement surpris de la d\u00e9finition de la connexit\u00e9, par exemple). N\u00e9anmoins, \u00e7a manque de boules et d'ouverts tout cela ! J'ai commenc\u00e9 \u00e0 prendre go\u00fbt \u00e0 la manipulation de quantificateurs en lisant le Monasse (en bidouillant les relations de comparaison (o et O de Landau)). Reste plus qu'\u00e0 voir proprement la topologie en mettant les mains dans toutes ses histoires de quantificateurs et cie. Faut \u00e9galement dire que j'ai eu le droit \u00e0 une bien belle pr\u00e9sentation du rapport logique / topologie (suite \u00e0 une de mes questions) : </p> <p>Pour ta question, la connexit\u00e9 n'est pas forc\u00e9ment un truc qui revient dans ce dictionnaire, mais il y a un tr\u00e8s fort dictionnaire entre logique et topologie. Tu peux voir la logique classique (\"bool\u00e9enne\") comme quelque chose qui gouverne les parties d'un ensemble, P(X), et de la m\u00eame mani\u00e8re, la logique dite \"intuitionniste\" (o\u00f9 on retire le raisonnement par l'absurde/le tiers exclu) gouverne les ouverts d'un espace topologique, O(X). C'est un des liens entre logique et topologie, mais il y en a d'autres. </p> <p>La topologie est souvent vue comme l'\u00e9tude des espaces, des formes, mais elle a un autre r\u00f4le, qui interagit souvent avec la logique, \u00e0 savoir le r\u00f4le d'imposer des restrictions, du \"contr\u00f4le\" sur des structures autrement assez compliqu\u00e9es \u00e0 g\u00e9rer. Il s'av\u00e8re qu'on peut souvent mettre des topologies raisonnables sur des ensembles de propositions, ou des ensembles de th\u00e9ories du premier ordre, m\u00eame plus simplement de th\u00e9ories propositionnelles, qui aident \u00e0 les \u00e9tudier. Comme il s'agit souvent de trucs reli\u00e9s \u00e0 l'ensemble discret {0,1} , ces topologies sont \u00e0 la fois tr\u00e8s sympathiques formellement (beaucoup de propri\u00e9t\u00e9s de r\u00e9gularit\u00e9, de compacit\u00e9, de discr\u00e9tude), mais aussi diff\u00e9rentes de celles dont on a l'habitude (tr\u00e8s rarement connexes, souvent incomparables \u00e0 nos espaces pr\u00e9f\u00e9r\u00e9s comme R^n). Bref, cela fait de cette topologie un truc un peu \u00e9loign\u00e9 d'une certaine image de la topologie, mais \u00e7a n'en est pas moins utile. </p>"},{"location":"blog/4-entree-au-fab-lab/","title":"4 - L'entr\u00e9e au Fab Lab","text":"<p>Une petite visite \u00e9clair au Fab Lab de mon universit\u00e9 pour se rendre compte que, malheureusement, il ne fallait pas trop compter sur cette structure (pour ce qui concerne l'\u00e9lectronique; au-del\u00e0 des traditionnels Arduino).</p> <p>Coup du sort, le lendemain matin, un ami m'envoie un message pour me pr\u00e9venir que le Fab Lab est ferm\u00e9 jusqu'\u00e0 nouvel ordre en raison de factures impay\u00e9es...</p> <p>En revanche, il se peut que des personnes s'y connaissent tr\u00e8s bien en programmation et / ou \u00e9lectronique. (Mais, dans la mesure, o\u00f9 ils n'avaient pas d'oscilloscope et que du mat\u00e9riel tr\u00e8s rudimentaire, je ne sais pas... En revanche, ils sont bien fournis en imprimantes 3D et cie.)</p> <p>Bref, malheureusement, non. Pas de Fab Lab pour moi.</p>"},{"location":"blog/5-ben-eater-ce-heros/","title":"5 - Ben Eater (et cie), ces h\u00e9ros...","text":""}]}